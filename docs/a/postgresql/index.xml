<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Postgresql on Deuts Log</title>
    <link>https://deuts.org/a/postgresql/</link>
    <description>Recent content in Postgresql on Deuts Log</description>
    <generator>Hugo -- 0.139.3</generator>
    <language>en</language>
    <copyright>2024 Deuts Log</copyright>
    <lastBuildDate>Wed, 20 Nov 2024 13:20:59 +0800</lastBuildDate>
    <atom:link href="https://deuts.org/a/postgresql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Why I Prefer SQLite-Only Docker Services</title>
      <link>https://deuts.org/p/why-sqlite-docker/</link>
      <pubDate>Wed, 20 Nov 2024 13:20:59 +0800</pubDate>
      <guid>https://deuts.org/p/why-sqlite-docker/</guid>
      <description>SQLite’s embedded nature eliminates the need for complex client-server setups, reducing overhead and simplifying Docker configurations. It’s lightweight, fast, and easy to set up, making it an ideal choice for solo users and low-traffic applications.</description>
      <content:encoded><![CDATA[<p>When setting up Docker containers, choosing the one with minimal setup can significantly affect the overall performance, complexity, and maintenance requirements of your services. For many use cases, especially when I’m the sole user of the system, I find that SQLite is the perfect database choice. Here&rsquo;s why:</p>
<ul>
<li><strong>Minimal Number of Containers</strong> – SQLite doesn’t require a separate database server, which keeps the setup minimal. Fewer containers mean less complexity, making the Docker environment easier to maintain and monitor.</li>
<li><strong>I’m the Only User Most of the Time</strong> – SQLite is embedded into the application, so there’s no need for complex client-server systems when I’m the only user. This makes it a perfect fit for small-scale, low-traffic use cases.</li>
<li><strong>Lightweight, Fast, and Easy to Set Up</strong> – SQLite is lightweight and fast, with no server to configure or maintain. The database is stored in a single file, making setup quick and Docker Compose files easier to manage.</li>
<li><strong>Reduced Maintenance and Overhead</strong> – Without the need for database clustering, replication, or scaling, SQLite simplifies maintenance. I only need to manage one file and ensure backups are in place.</li>
<li><strong>Portability and Flexibility</strong> – SQLite databases are stored as single files, so they can be easily moved, backed up, or transferred between environments without complex configurations or network dependencies.</li>
<li><strong>Less Network Overhead</strong> – Since SQLite runs locally, there’s no need for network communication, resulting in faster response times and reduced network overhead compared to client-server databases.</li>
</ul>
<p>Whenever I’m presented with multiple Docker services that serve the same purpose, or when an SQLite-only option is available, I usually prefer SQLite. Case in point: <a href="/p/medama-vs-google-analytics/">Why I chose Medama</a>. It&rsquo;s simple and fulfills my needs without the overhead of managing an additional database server, making it perfect for personal projects, prototypes, and low-traffic applications.</p>
<p>I recognize that SQLite might not always be the best choice for every project, and I’m open to hearing differing perspectives. If you believe a dedicated database like MySQL, PostgreSQL, or another RDBMS is the better route, I’d love to hear why.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
